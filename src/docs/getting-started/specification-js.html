
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Document</title>
 <!-- 引入head -->
 {{include '../../../base/public/header'}}
</head>
<body>
 <!-- side bar -->
 <div>
 <ul> <li><a href="message.html">提示消息 message</a></li> <li><a href="pagination.html">分页 pagination</a></li> <li><a href="message.html">消息 message</a></li> <li><a href="tooltip.html">提示 tooltip</a></li> <li><a href="breadcrumb.html">面包屑 breadcrumb</a></li> <li><a href="panel.html">面板 panel</a></li> <li><a href="dropdown.html">下拉 dropdown</a></li> <li><a href="buttongroup.html">按钮组 buttongroup</a></li> <li><a href="inputgroup.html">输入框组 inputgroup</a></li> <li><a href="navbar.html">导航条 navbar</a></li> <li><a href="thumbnail.html">缩略图 thumbnail</a></li> <li><a href="media.html">媒体对象 meida</a></li> <li><a href="listgroup.html">列表组 listgroup</a></li> <li><a href="gallery.html">图片画廊 gallery</a></li> <li><a href="statisticWidget.html">卡片</a></li> </ul>
 </div>

 <!-- content -->
 <div>
 
<h1 id="javascript-">JavaScript 编码规范</h1>
<p>此为前端开发团队遵循和约定的 JavaScript 编码规范，意在提高代码的规范性和可维护性。</p>
<h2 id="-a-name-types-a-"><a name='types'>类型</a></h2>
<ul>
<li><p><strong>原始值</strong>: 相当于传值</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
<pre><code class="lang-javascript">var foo = 1,
 bar = foo;

bar = 9;

console.log(foo, bar); // =&gt; 1, 9
</code></pre>
</li>
<li><p><strong>复杂类型</strong>: 相当于传引用</p>
<ul>
<li><code>object</code></li>
<li><code>array</code></li>
<li><code>function</code></li>
</ul>
<pre><code class="lang-javascript">var foo = [1, 2],
 bar = foo;

bar[0] = 9;

console.log(foo[0], bar[0]); // =&gt; 9, 9
</code></pre>
</li>
</ul>
<h2 id="-a-name-objects-a-"><a name='objects'>对象</a></h2>
<ul>
<li><p>使用字面值创建对象</p>
<pre><code class="lang-javascript">// bad
var item = new Object();

// good
var item = {};
</code></pre>
</li>
<li><p>不要使用保留字 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Reserved_Words">reserved words</a> 作为键</p>
<pre><code class="lang-javascript">// bad
var superman = {
 class: &#39;superhero&#39;,
 default: { clark: &#39;kent&#39; },
 private: true
};

// good
var superman = {
 klass: &#39;superhero&#39;,
 defaults: { clark: &#39;kent&#39; },
 hidden: true
};
</code></pre>
</li>
</ul>
<h2 id="-a-name-arrays-a-"><a name='arrays'>数组</a></h2>
<ul>
<li><p>使用字面值创建数组</p>
<pre><code class="lang-javascript">// bad
var items = new Array();

// good
var items = [];
</code></pre>
</li>
<li><p>如果你不知道数组的长度，使用push</p>
<pre><code class="lang-javascript">var someStack = [];

// bad
someStack[someStack.length] = &#39;abracadabra&#39;;

// good
someStack.push(&#39;abracadabra&#39;);
</code></pre>
</li>
<li><p>当你需要拷贝数组时使用slice</p>
<pre><code class="lang-javascript">var len = items.length,
 itemsCopy = [],
 i;

// bad
for (i = 0; i &lt; len; i++) {
 itemsCopy[i] = items[i];
}

// good
itemsCopy = items.slice();
</code></pre>
</li>
<li><p>使用slice将类数组的对象转成数组.</p>
<pre><code class="lang-javascript">function trigger() {
 var args = Array.prototype.slice.call(arguments);
 ...
}
</code></pre>
</li>
</ul>
<h2 id="-a-name-strings-a-"><a name='strings'>字符串</a></h2>
<ul>
<li><p>对字符串使用单引号 <code>&#39;&#39;</code></p>
<pre><code class="lang-javascript">// bad
var name = &quot;Bob Parr&quot;;

// good
var name = &#39;Bob Parr&#39;;

// bad
var fullName = &quot;Bob &quot; + this.lastName;

// good
var fullName = &#39;Bob &#39; + this.lastName;
</code></pre>
</li>
<li><p>超过80个字符的字符串应该使用字符串连接换行</p>
<ul>
<li>注: 如果过度使用，长字符串连接可能会对性能有影响.</li>
</ul>
<pre><code class="lang-javascript">// bad
var errorMessage = &#39;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&#39;;

// bad
var errorMessage = &#39;This is a super long error that \nwas thrown because of Batman. \nWhen you stop to think about \nhow Batman had anything to do \nwith this, you would get nowhere \nfast.&#39;;

// good
var errorMessage = &#39;This is a super long error that &#39; +
&#39;was thrown because of Batman.&#39; +
&#39;When you stop to think about &#39; +
&#39;how Batman had anything to do &#39; +
&#39;with this, you would get nowhere &#39; +
&#39;fast.&#39;;
</code></pre>
</li>
</ul>
<ul>
<li><p>编程时使用join而不是字符串连接来构建字符串，特别是IE</p>
<pre><code class="lang-javascript">var items,
 messages,
 length, i;

messages = [{
 state: &#39;success&#39;,
 message: &#39;This one worked.&#39;
},{
 state: &#39;success&#39;,
 message: &#39;This one worked as well.&#39;
},{
 state: &#39;error&#39;,
 message: &#39;This one did not work.&#39;
}];

length = messages.length;

// bad
function inbox(messages) {
 items = &#39;&lt;ul&gt;&#39;;

 for (i = 0; i &lt; length; i++) {
 items += &#39;&lt;li&gt;&#39; + messages[i].message + &#39;&lt;/li&gt;&#39;;
 }

 return items + &#39;&lt;/ul&gt;&#39;;
}

// good
function inbox(messages) {
 items = [];

 for (i = 0; i &lt; length; i++) {
 items[i] = messages[i].message;
 }

 return &#39;&lt;ul&gt;&lt;li&gt;&#39; + items.join(&#39;&lt;/li&gt;&lt;li&gt;&#39;) + &#39;&lt;/li&gt;&lt;/ul&gt;&#39;;
}
</code></pre>
</li>
</ul>
<h2 id="-a-name-functions-a-"><a name='functions'>函数</a></h2>
<ul>
<li><p>函数表达式:</p>
<pre><code class="lang-javascript">// 匿名函数表达式
var anonymous = function() {
 return true;
};

// 有名函数表达式
var named = function named() {
 return true;
};

// 立即调用函数表达式
(function() {
 console.log(&#39;Welcome to the Internet. Please follow me.&#39;);
})();
</code></pre>
</li>
<li><p>绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同。</p>
<ul>
<li><strong>注:</strong> ECMA-262定义把<code>块</code>定义为一组语句，函数声明不是一个语句。<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97">阅读ECMA-262对这个问题的说明</a>.</li>
</ul>
<pre><code class="lang-javascript">// bad
if (currentUser) {
 function test() {
 console.log(&#39;Nope.&#39;);
 }
}

// good
if (currentUser) {
 var test = function test() {
 console.log(&#39;Yup.&#39;);
 };
}
</code></pre>
<ul>
<li>绝对不要把参数命名为 <code>arguments</code>, 这将会逾越函数作用域内传过来的 <code>arguments</code> 对象.</li>
</ul>
<pre><code class="lang-javascript">// bad
function nope(name, options, arguments) {
 // ...stuff...
}

// good
function yup(name, options, args) {
 // ...stuff...
}
</code></pre>
</li>
</ul>
<h2 id="-a-name-properties-a-"><a name='properties'>属性</a></h2>
<ul>
<li><p>当使用变量访问属性时使用中括号.</p>
<pre><code class="lang-javascript">var luke = {
 jedi: true,
 age: 28
};

function getProp(prop) {
 return luke[prop];
}

var isJedi = getProp(&#39;jedi&#39;);
</code></pre>
</li>
</ul>
<h2 id="-a-name-variables-a-"><a name='variables'>变量</a></h2>
<ul>
<li><p>总是使用 <code>var</code> 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间。</p>
<pre><code class="lang-javascript">// bad
superPower = new SuperPower();

// good
var superPower = new SuperPower();
</code></pre>
</li>
<li><p>使用一个 <code>var</code> 以及新行声明多个变量，缩进4个空格。</p>
<pre><code class="lang-javascript">// bad
var items = getItems();
var goSportsTeam = true;
var dragonball = &#39;z&#39;;

// good
var items = getItems(),
 goSportsTeam = true,
 dragonball = &#39;z&#39;;
</code></pre>
<ul>
<li>最后再声明未赋值的变量，当你想引用之前已赋值变量的时候很有用。</li>
</ul>
<pre><code class="lang-javascript">// bad
var i, len, dragonball,
 items = getItems(),
 goSportsTeam = true;

// bad
var i, items = getItems(),
 dragonball,
 goSportsTeam = true,
 len;

// good
var items = getItems(),
 goSportsTeam = true,
 dragonball,
 length,
 i;
</code></pre>
<ul>
<li>在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。</li>
</ul>
<pre><code class="lang-javascript">// bad
function() {
 test();
 console.log(&#39;doing stuff..&#39;);

 //..other stuff..

 var name = getName();

 if (name === &#39;test&#39;) {
 return false;
 }

 return name;
}

// good
function() {
 var name = getName();

 test();
 console.log(&#39;doing stuff..&#39;);

 //..other stuff..

 if (name === &#39;test&#39;) {
 return false;
 }

 return name;
}

// bad
function() {
 var name = getName();

 if (!arguments.length) {
 return false;
 }

 return true;
}

// good
function() {
 if (!arguments.length) {
 return false;
 }

 var name = getName();

 return true;
}
</code></pre>
</li>
</ul>
<h2 id="-a-name-conditionals-a-"><a name='conditionals'>条件表达式和等号</a></h2>
<ul>
<li>适当使用 <code>===</code> 和 <code>!==</code> 以及 <code>==</code> 和 <code>!=</code>.</li>
<li><p>条件表达式的强制类型转换遵循以下规则：</p>
<ul>
<li><strong>对象</strong> 被计算为 <strong>true</strong></li>
<li><strong>Undefined</strong> 被计算为 <strong>false</strong></li>
<li><strong>Null</strong> 被计算为 <strong>false</strong></li>
<li><strong>布尔值</strong> 被计算为 <strong>布尔的值</strong></li>
<li><strong>数字</strong> 如果是 <strong>+0, -0, or NaN</strong> 被计算为 <strong>false</strong> , 否则为 <strong>true</strong></li>
<li><strong>字符串</strong> 如果是空字符串 <code>&#39;&#39;</code> 则被计算为 <strong>false</strong>, 否则为 <strong>true</strong></li>
</ul>
<pre><code class="lang-javascript">if ([0]) {
 // true
 // An array is an object, objects evaluate to true
}
</code></pre>
</li>
<li><p>使用快捷方式.</p>
<pre><code class="lang-javascript">// bad
if (name !== &#39;&#39;) {
 // ...stuff...
}

// good
if (name) {
 // ...stuff...
}

// bad
if (collection.length &gt; 0) {
 // ...stuff...
}

// good
if (collection.length) {
 // ...stuff...
}
</code></pre>
<ul>
<li>阅读 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108">Truth Equality and JavaScript</a> 了解更多</li>
</ul>
</li>
</ul>
<h2 id="-a-name-blocks-a-"><a name='blocks'>块</a></h2>
<ul>
<li><p>给所有多行的块使用大括号</p>
<pre><code class="lang-javascript">// bad
if (test)
 return false;

// good
if (test) return false;

// good
if (test) {
 return false;
}

// bad
function() { return false; }

// good
function() {
 return false;
}
</code></pre>
</li>
</ul>
<h2 id="-a-name-comments-a-"><a name='comments'>注释</a></h2>
<ul>
<li><p>使用 <code>/** ... */</code> 进行多行注释，包括描述，指定类型以及参数值和返回值</p>
<pre><code class="lang-javascript">// bad
// make() returns a new element
// based on the passed in tag name
//
// @param &lt;String&gt; tag
// @return &lt;Element&gt; element
function make(tag) {

 // ...stuff...

 return element;
}

// good
/**
* make() returns a new element
* based on the passed in tag name
* @param &lt;String&gt; tag
* @return &lt;Element&gt; element
*/
function make(tag) {
 // ...stuff...
 return element;
}
</code></pre>
</li>
</ul>
<ul>
<li><p>使用 <code>//</code> 进行单行注释，在评论对象的上面进行单行注释，注释前放一个空行.</p>
<pre><code class="lang-javascript">// bad
var active = true; // is current tab

// good
// is current tab
var active = true;

// bad
function getType() {
 console.log(&#39;fetching type...&#39;);
 // set the default type to &#39;no type&#39;
 var type = this._type || &#39;no type&#39;;

 return type;
}

// good
function getType() {
 console.log(&#39;fetching type...&#39;);

 // set the default type to &#39;no type&#39;
 var type = this._type || &#39;no type&#39;;

 return type;
}
</code></pre>
<ul>
<li>如果你有一个问题需要重新来看一下或如果你建议一个需要被实现的解决方法的话需要在你的注释前面加上 <code>FIXME</code> 或 <code>TODO</code> 帮助其他人迅速理解</li>
</ul>
<pre><code class="lang-javascript">function Calculator() {

 // FIXME: shouldn&#39;t use a global here
 total = 0;

 return this;
}
</code></pre>
<pre><code class="lang-javascript">function Calculator() {

 // TODO: total should be configurable by an options param
 this.total = 0;

 return this;
}
</code></pre>
</li>
</ul>
<h2 id="-a-name-whitespace-a-"><a name='whitespace'>空白</a></h2>
<ul>
<li><p>将tab设为4个空格</p>
<pre><code class="lang-javascript">// bad
function() {
 ∙∙var name;
}

// bad
function() {
 ∙var name;
}

// good
function() {
 ∙∙∙∙var name;
}
</code></pre>
</li>
<li><p>大括号前放一个空格</p>
<pre><code class="lang-javascript">// bad
function test(){
 console.log(&#39;test&#39;);
}

// good
function test() {
 console.log(&#39;test&#39;);
}

// bad
dog.set(&#39;attr&#39;,{
 age: &#39;1 year&#39;,
 breed: &#39;Bernese Mountain Dog&#39;
});

// good
dog.set(&#39;attr&#39;, {
 age: &#39;1 year&#39;,
 breed: &#39;Bernese Mountain Dog&#39;
});
</code></pre>
<ul>
<li>在做长方法链时使用缩进.</li>
</ul>
<pre><code class="lang-javascript">// bad
$(&#39;#items&#39;).find(&#39;.selected&#39;).highlight().end().find(&#39;.open&#39;).updateCount();

// good
$(&#39;#items&#39;)
 .find(&#39;.selected&#39;)
 .highlight()
 .end()
 .find(&#39;.open&#39;)
 .updateCount();

// bad
var leds = stage.selectAll(&#39;.led&#39;).data(data).enter().append(&#39;svg:svg&#39;).class(&#39;led&#39;, true)
 .attr(&#39;width&#39;, (radius + margin) SUMMARY.html breadcrumb.html browser.html buttongroup.html css.html dir.html dropdown.html faq.html feedback.html gallery.html index.html inputgroup.html js.html kero.html listgroup.html media.html menu.html message.html navbar.html page.html pagination.html panel.html pearls.html performance.html progress.html quitstart-kero.html quitstart-project.html quitstart-ui.html rating.html scaffold.html specification-css.html specification-js.html statisticWidget.html switchButton.html theme.html thumbnail.html tools.html tooltip.html tree.html version.html 2).append(&#39;svg:g&#39;)
 .attr(&#39;transform&#39;, &#39;translate(&#39; + (radius + margin) + &#39;,&#39; + (radius + margin) + &#39;)&#39;)
 .call(tron.led);

// good
var leds = stage.selectAll(&#39;.led&#39;)
 .data(data)
 .enter().append(&#39;svg:svg&#39;)
 .class(&#39;led&#39;, true)
 .attr(&#39;width&#39;, (radius + margin) SUMMARY.html breadcrumb.html browser.html buttongroup.html css.html dir.html dropdown.html faq.html feedback.html gallery.html index.html inputgroup.html js.html kero.html listgroup.html media.html menu.html message.html navbar.html page.html pagination.html panel.html pearls.html performance.html progress.html quitstart-kero.html quitstart-project.html quitstart-ui.html rating.html scaffold.html specification-css.html specification-js.html statisticWidget.html switchButton.html theme.html thumbnail.html tools.html tooltip.html tree.html version.html 2)
 .append(&#39;svg:g&#39;)
 .attr(&#39;transform&#39;, &#39;translate(&#39; + (radius + margin) + &#39;,&#39; + (radius + margin) + &#39;)&#39;)
 .call(tron.led);
</code></pre>
</li>
</ul>
<h2 id="-a-name-commas-a-"><a name='commas'>逗号</a></h2>
<ul>
<li><p>不要将逗号放前面</p>
<pre><code class="lang-javascript">// bad
var once
 , upon
 , aTime;

// good
var once,
 upon,
 aTime;

// bad
var hero = {
 firstName: &#39;Bob&#39;
 , lastName: &#39;Parr&#39;
 , heroName: &#39;Mr. Incredible&#39;
 , superPower: &#39;strength&#39;
};

// good
var hero = {
 firstName: &#39;Bob&#39;,
 lastName: &#39;Parr&#39;,
 heroName: &#39;Mr. Incredible&#39;,
 superPower: &#39;strength&#39;
};
</code></pre>
</li>
<li><p>不要加多余的逗号，这可能会在IE下引起错误，同时如果多一个逗号某些ES3的实现会计算多数组的长度。</p>
<pre><code class="lang-javascript">// bad
var hero = {
 firstName: &#39;Kevin&#39;,
 lastName: &#39;Flynn&#39;,
};

var heroes = [
 &#39;Batman&#39;,
 &#39;Superman&#39;,
];

// good
var hero = {
 firstName: &#39;Kevin&#39;,
 lastName: &#39;Flynn&#39;
};

var heroes = [
 &#39;Batman&#39;,
 &#39;Superman&#39;
];
</code></pre>
</li>
</ul>
<h2 id="-a-name-semicolons-a-"><a name='semicolons'>分号</a></h2>
<ul>
<li><p>语句结束一定要加分号</p>
<pre><code class="lang-javascript">// bad
(function() {
 var name = &#39;Skywalker&#39;
 return name
})()

// good
(function() {
 var name = &#39;Skywalker&#39;;
 return name;
})();

// good
;(function() {
 var name = &#39;Skywalker&#39;;
 return name;
})();
</code></pre>
</li>
</ul>
<h2 id="-a-name-type-coercion-a-"><a name='type-coercion'>类型转换</a></h2>
<ul>
<li>在语句的开始执行类型转换.</li>
<li><p>字符串:</p>
<pre><code class="lang-javascript">// =&gt; this.reviewScore = 9;

// bad
var totalScore = this.reviewScore + &#39;&#39;;

// good
var totalScore = &#39;&#39; + this.reviewScore;

// bad
var totalScore = &#39;&#39; + this.reviewScore + &#39; total score&#39;;

// good
var totalScore = this.reviewScore + &#39; total score&#39;;
</code></pre>
<ul>
<li>对数字使用 <code>parseInt</code> 并且总是带上类型转换的基数.</li>
</ul>
<pre><code class="lang-javascript">var inputValue = &#39;4&#39;;

// bad
var val = new Number(inputValue);

// bad
var val = +inputValue;

// bad
var val = inputValue &gt;&gt; 0;

// bad
var val = parseInt(inputValue);

// good
var val = Number(inputValue);

// good
var val = parseInt(inputValue, 10);

// good
/**
* parseInt was the reason my code was slow.
* Bitshifting the String to coerce it to a
* Number made it a lot faster.
*/
var val = inputValue &gt;&gt; 0;
</code></pre>
<ul>
<li>布尔值:</li>
</ul>
<pre><code class="lang-javascript">var age = 0;

// bad
var hasAge = new Boolean(age);

// good
var hasAge = Boolean(age);

// good
var hasAge = !!age;
</code></pre>
</li>
</ul>
<h2 id="-a-name-naming-conventions-a-"><a name='naming-conventions'>命名约定</a></h2>
<ul>
<li><p>避免单个字符名，让你的变量名有描述意义。</p>
<pre><code class="lang-javascript">// bad
function q() {
 // ...stuff...
}

// good
function query() {
 // ..stuff..
}
</code></pre>
</li>
<li><p>当命名对象、函数和实例时使用驼峰命名规则</p>
<pre><code class="lang-javascript">// bad
var OBJEcttsssss = {};
var this_is_my_object = {};
var this-is-my-object = {};
function c() {};
var u = new user({
 name: &#39;Bob Parr&#39;
});

// good
var thisIsMyObject = {};
function thisIsMyFunction() {};
var user = new User({
 name: &#39;Bob Parr&#39;
});
</code></pre>
<ul>
<li><p>当命名构造函数或类时使用驼峰式大写</p>
<pre><code class="lang-javascript">// bad
function user(options) {
 this.name = options.name;
}

var bad = new user({
 name: &#39;nope&#39;
});

// good
function User(options) {
 this.name = options.name;
}

var good = new User({
 name: &#39;yup&#39;
});
</code></pre>
</li>
<li><p>命名私有属性时前面加个下划线 <code>_</code></p>
<pre><code class="lang-javascript">// bad
this.__firstName__ = &#39;Panda&#39;;
this.firstName_ = &#39;Panda&#39;;

// good
this._firstName = &#39;Panda&#39;;
</code></pre>
</li>
<li><p>当保存对 <code>this</code> 的引用时使用 <code>_this</code>.</p>
<pre><code class="lang-javascript">// bad
function() {
 var self = this;
 return function() {
 console.log(self);
 };
}

// bad
function() {
 var that = this;
 return function() {
 console.log(that);
 };
}

// good
function() {
 var _this = this;
 return function() {
 console.log(_this);
 };
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="-a-name-accessors-a-"><a name='accessors'>存取器</a></h2>
<ul>
<li>属性的存取器函数不是必需的</li>
<li><p>如果你确实有存取器函数的话使用getVal() 和 setVal(&#39;hello&#39;)</p>
<pre><code class="lang-javascript">// bad
dragon.age();

// good
dragon.getAge();

// bad
dragon.age(25);

// good
dragon.setAge(25);
</code></pre>
<ul>
<li>如果属性是布尔值，使用isVal() 或 hasVal()</li>
</ul>
<pre><code class="lang-javascript">// bad
if (!dragon.age()) {
 return false;
}

// good
if (!dragon.hasAge()) {
 return false;
}
</code></pre>
<ul>
<li>可以创建get()和set()函数，但是要保持一致</li>
</ul>
<pre><code class="lang-javascript">function Jedi(options) {
 options || (options = {});
 var lightsaber = options.lightsaber || &#39;blue&#39;;
 this.set(&#39;lightsaber&#39;, lightsaber);
}

Jedi.prototype.set = function(key, val) {
 this[key] = val;
};

Jedi.prototype.get = function(key) {
 return this[key];
};
</code></pre>
</li>
</ul>
<h2 id="-a-name-constructors-a-"><a name='constructors'>构造器</a></h2>
<ul>
<li><p>给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题。</p>
<pre><code class="lang-javascript">function Jedi() {
 console.log(&#39;new jedi&#39;);
}

// bad
Jedi.prototype = {
 fight: function fight() {
 console.log(&#39;fighting&#39;);
 },

 block: function block() {
 console.log(&#39;blocking&#39;);
 }
};

// good
Jedi.prototype.fight = function fight() {
 console.log(&#39;fighting&#39;);
};

Jedi.prototype.block = function block() {
 console.log(&#39;blocking&#39;);
};
</code></pre>
</li>
<li><p>方法可以返回 <code>this</code> 帮助方法可链。</p>
<pre><code class="lang-javascript">// bad
Jedi.prototype.jump = function() {
 this.jumping = true;
 return true;
};

Jedi.prototype.setHeight = function(height) {
 this.height = height;
};

var luke = new Jedi();
luke.jump(); // =&gt; true
luke.setHeight(20) // =&gt; undefined

// good
Jedi.prototype.jump = function() {
 this.jumping = true;
 return this;
};

Jedi.prototype.setHeight = function(height) {
 this.height = height;
 return this;
};

var luke = new Jedi();

luke.jump()
 .setHeight(20);
</code></pre>
</li>
</ul>
<ul>
<li><p>可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用。</p>
<pre><code class="lang-javascript">function Jedi(options) {
 options || (options = {});
 this.name = options.name || &#39;no name&#39;;
}

Jedi.prototype.getName = function getName() {
 return this.name;
};

Jedi.prototype.toString = function toString() {
 return &#39;Jedi - &#39; + this.getName();
};
</code></pre>
</li>
</ul>
<h2 id="-a-name-events-a-"><a name='events'>事件</a></h2>
<ul>
<li><p>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器</p>
<pre><code class="lang-js">// bad
$(this).trigger(&#39;listingUpdated&#39;, listing.id);

...

$(this).on(&#39;listingUpdated&#39;, function(e, listingId) {
 // do something with listingId
});
</code></pre>
<p> 更好:</p>
<pre><code class="lang-js">// good
$(this).trigger(&#39;listingUpdated&#39;, { listingId : listing.id });

...

$(this).on(&#39;listingUpdated&#39;, function(e, data) {
 // do something with data.listingId
});
</code></pre>
</li>
</ul>
<h2 id="-a-name-modules-a-"><a name='modules'>模块</a></h2>
<ul>
<li>模块应该以 <code>!</code> 开始，这保证了如果一个有问题的模块忘记包含最后的分号在合并后不会出现错误</li>
<li><p>这个文件应该以驼峰命名，并在同名文件夹下，同时导出的时候名字一致</p>
<ul>
<li>加入一个名为noConflict()的方法来设置导出的模块为之前的版本并返回它</li>
<li>总是在模块顶部声明 <code>&#39;use strict&#39;;</code></li>
</ul>
<pre><code class="lang-javascript">// fancyInput/fancyInput.js

!function(global) {
 &#39;use strict&#39;;

 var previousFancyInput = global.FancyInput;

 function FancyInput(options) {
 this.options = options || {};
 }

 FancyInput.noConflict = function noConflict() {
 global.FancyInput = previousFancyInput;
 return FancyInput;
 };

 global.FancyInput = FancyInput;
}(this);
</code></pre>
</li>
</ul>
<h2 id="-a-name-jquery-jquery-a-"><a name='jquery'>jQuery</a></h2>
<ul>
<li><p>缓存jQuery查询</p>
<pre><code class="lang-javascript">// bad
function setSidebar() {
 $(&#39;.sidebar&#39;).hide();

 // ...stuff...

 $(&#39;.sidebar&#39;).css({
 &#39;background-color&#39;: &#39;pink&#39;
 });
}

// good
function setSidebar() {
 var $sidebar = $(&#39;.sidebar&#39;);
 $sidebar.hide();

 // ...stuff...

 $sidebar.css({
 &#39;background-color&#39;: &#39;pink&#39;
 });
}
</code></pre>
</li>
<li><p>对DOM查询使用级联的 <code>$(&#39;.sidebar ul&#39;)</code> 或 <code>$(&#39;.sidebar ul&#39;)</code></p>
<ul>
<li>对有作用域的jQuery对象查询使用 <code>find</code></li>
</ul>
<pre><code class="lang-javascript">// bad
$(&#39;.sidebar&#39;, &#39;ul&#39;).hide();

// bad
$(&#39;.sidebar&#39;).find(&#39;ul&#39;).hide();

// good
$(&#39;.sidebar ul&#39;).hide();

// good
$(&#39;.sidebar &gt; ul&#39;).hide();

// good (slower)
$sidebar.find(&#39;ul&#39;);

// good (faster)
$($sidebar[0]).find(&#39;ul&#39;);
</code></pre>
</li>
</ul>
<h2 id="-a-name-es5-ecmascript-5-a-"><a name='es5'>ECMAScript 5兼容性</a></h2>
<ul>
<li>参考Kangax的 ES5 <a href="http://kangax.github.com/es5-compat-table/">compatibility table</a></li>
</ul>
<h2 id="-a-name-performance-a-"><a name='performance'>性能</a></h2>
<ul>
<li><a href="http://kellegous.com/j/2013/01/26/layout-performance/">On Layout &amp; Web Performance</a></li>
<li><a href="http://jsperf.com/string-vs-array-concat/2">String vs Array Concat</a><ul>
<li><a href="http://jsperf.com/try-catch-in-loop-cost">Try/Catch Cost In a Loop</a></li>
<li><a href="http://jsperf.com/bang-function">Bang Function</a></li>
<li><a href="http://jsperf.com/jquery-find-vs-context-sel/13">jQuery Find vs Context, Selector</a></li>
<li><a href="http://jsperf.com/innerhtml-vs-textcontent-for-script-text">innerHTML vs textContent for script text</a></li>
<li><a href="http://jsperf.com/ya-string-concat">Long String Concatenation</a></li>
<li>Loading...</li>
</ul>
</li>
</ul>
<h2 id="-a-name-resources-a-"><a name='resources'>资源</a></h2>
<p><strong>Read This</strong></p>
<ul>
<li><a href="http://es5.github.com/">Annotated ECMAScript 5.1</a></li>
</ul>
<p><strong>其它规范</strong></p>
<ul>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">Google JavaScript Style Guide</a></li>
<li><a href="http://docs.jquery.com/JQuery_Core_Style_Guidelines">jQuery Core Style Guidelines</a><ul>
<li><a href="https://github.com/rwldrn/idiomatic.js/">Principles of Writing Consistent, Idiomatic JavaScript</a></li>
</ul>
</li>
</ul>
<p><strong>其它风格</strong></p>
<ul>
<li><a href="https://gist.github.com/4135065">Naming this in nested functions</a> - Christian Johansen</li>
<li><a href="https://github.com/airbnb/javascript/issues/52">Conditional Callbacks</a></li>
</ul>
<p><strong>阅读更多</strong></p>
<ul>
<li><a href="http://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/">Understanding JavaScript Closures</a> - Angus Croll</li>
</ul>
<p><strong>书籍</strong></p>
<ul>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript: The Good Parts</a> - Douglas Crockford</li>
<li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns</a> - Stoyan Stefanov<ul>
<li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X">Pro JavaScript Design Patterns</a> - Ross Harmes and Dustin Diaz</li>
<li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309">High Performance Web Sites: Essential Knowledge for Front-End Engineers</a> - Steve Souders</li>
<li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680">Maintainable JavaScript</a> - Nicholas C. Zakas</li>
<li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X">JavaScript Web Applications</a> - Alex MacCaw</li>
<li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273">Pro JavaScript Techniques</a> - John Resig</li>
<li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li>
</ul>
</li>
</ul>
<p><strong>博客</strong></p>
<ul>
<li><a href="http://adamlu.com/">Adam Lu</a></li>
<li><a href="http://dailyjs.com/">DailyJS</a><ul>
<li><a href="http://javascriptweekly.com/">JavaScript Weekly</a></li>
<li><a href="http://javascriptweblog.wordpress.com/">JavaScript, JavaScript...</a></li>
<li><a href="http://weblog.bocoup.com/">Bocoup Weblog</a></li>
<li><a href="http://www.adequatelygood.com/">Adequately Good</a></li>
<li><a href="http://www.nczonline.net/">NCZOnline</a></li>
<li><a href="http://perfectionkills.com/">Perfection Kills</a></li>
<li><a href="http://benalman.com/">Ben Alman</a></li>
<li><a href="http://dmitry.baranovskiy.com/">Dmitry Baranovskiy</a></li>
<li><a href="http://dustindiaz.com/">Dustin Diaz</a></li>
<li><a href="http://net.tutsplus.com/?s=javascript">nettuts</a></li>
</ul>
</li>
</ul>
<h1 id="-">声明</h1>
<blockquote>
<p>本规范由<code>github</code>上<code>adamlu</code>同学翻译自<code>airbnb</code>出品的前端代码规范，<a href="https://github.com/GuoYongfeng/javascript">点这里查看原文</a></p>
</blockquote>
 </div>

 <!-- 引入end -->
 {{include '../../../base/public/footer'}}
</body>
</html>
